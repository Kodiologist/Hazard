#!/usr/bin/env python
# encoding: UTF-8
from psychopy import *
import pyglet
import wx
import os
import time
import datetime
import random, math, itertools
import pickle
import numpy
import json

def concat(x):
    return list(itertools.chain.from_iterable(x))

def shuffled(x):
    return random.sample(x, len(x))

waitKey_delay = .02
def waitKey(keyList = None):
    event.clearEvents('keyboard')
    while True:
        keys = event.getKeys()
        if keys and (keyList is None or keys[0] in keyList):
            return keys[0]
        time.sleep(waitKey_delay)

def log(f, t):
    print >>f, '\t'.join(['{}:\t{}'.format(k, t[k]) for k in (
        'time', 'trial', 'type', 'certainty',
        'riskmagnitude', 'probability', 'sharedloss',
        'matchedEVW', 'matchedEVL', 'rt', 'choice',
        'outcome', 'ttlrew')])
    f.flush()

def msg(x, y, text, height = .1, alignHoriz = 'center', alignVert = 'center', wrapWidth = 1):
    visual.TextStim(win, text = text,
       pos = (x, y), color = 'black', height = height,
       alignHoriz = alignHoriz, alignVert = alignVert,
       wrapWidth = wrapWidth).draw()

def drawtrial():
    msg(0, .75, player_assignments, height = .075,
      wrapWidth = 1.5)

    msg(0, .275, alignVert = 'top', text =
        '100% Win ${}\n\n\n\n{}% Win ${}\n{}% Lose ${}\n\n{}'.format(
        certainty,
        int(trial['probability']*100),
        trial['matchedEVW'] if trial['type'] == 'matched'
            else trial['riskmagnitude'],
        100 - int(trial['probability']*100),
        trial['matchedEVL'] if trial['type'] == 'matched'
            else trial['riskmagnitude'],
#    msg(0, -.5,
        'Shared Loss with\nPlayer A' if trial['type'] == 'sharedlosslocal' else
            'Shared Loss with\nPlayer B' if trial['type'] == 'sharedlossDuane' else
            'Shared Loss\n(as Player B)\nwith Player A' if trial['type'] == 'sharedlossAsDuane' else
            'Full Personal Loss'))

    visual.Rect(win, pos = (0, 0), width = 1, height = .01,
        fillColor = 'black').draw()

def drawoutcome(r):
    
    if trial['choice'] == 0:
        rew = certainty
        
    else:
        if trial['type'] == 'sharedlosseslocal':
            if random.random() < trial['probability']:
                rew = trial['riskmagnitude']
                
            else:
                rew = -trial['riskmagnitude']/2
                
        elif trial['type'] == 'sharedlossesDuane':
            if random.random() < trial['probability']:
                rew = trial['riskmagnitude']
                
            else:
                rew = -trial['riskmagnitude']/2
                
        elif trial['type'] == 'sharedlossesAsDuane':
            if random.random() < trial['probability']:
                rew = trial['riskmagnitude']
                
            else:
                rew = -trial['riskmagnitude']/2
                
        elif trial['type'] == 'matched':
            if random.random() < trial['probability']:
                rew = trial['matchedEVW']
                
            else:
                rew = -trial['matchedEVW']/2
        
        else:
            if random.random() < trial['probability']:
                rew = trial['riskmagnitude']
                
            else:
                rew = -trial['riskmagnitude']
                
    return rew

person_types = dict(
    best_friend = "Your best friend",
    parent = "The parent or stepparent you're closest to",
    friend_of_friend = "A friend of a friend",
    childhood_friend = "A childhood friend you haven't spoken to in years",
    local_partner = "Player A",
    occ_relative = "A relative you see no more than a few times a year",
    doctor = "Your primary physician",
    cashier = "A cashier at a store (or a university eatery)\nthat you go to often",
    remote_partner = "Player B",
    unmet_classmate = "A classmate you can recognize but\nyou've never spoken to",
    dead_relative = "A relative who you know a least a little about but\nwho died before you were born",
    stranger = "A stranger you've seen once or a few times and\nwho you know nothing about")

player_assignments = '''Player A: Your partner
Player B: Participant at SUNY Buffalo
Player C: You'''

#--------------------------------------------------INITIALISE DATA STRUCTURE

expData = []

certainty = 15
catch_magnitude = 10
riskymagnitudes = [20,30,40,50,60]
#sharedloss20 = [16,32,48]
#sharedloss50 = [10,20,30]
#matchedrisky = [10,20,30,40,60]
matchedEVW = [20,30,40,50,60]
probabilities = [.5,.6,.7,.8]
#percents = [50,60,70,80,90]
#sharedlosses = [20,50]
sharedlosses = [50]


for riskymagnitude in riskymagnitudes:
    for probability in probabilities:
        for hazard in sharedlosses:
            trial = {}
            trial['certainty'] = certainty
            trial['riskmagnitude'] = riskymagnitude
            trial['probability'] = probability
            trial['sharedloss'] = hazard
            trial['matchedEVW'] = -77
            trial['matchedEVL'] = -77
            trial['rt'] = -77 
            trial['choice'] = -77
            trial['outcome'] = -77
            trial['ttlrew'] = -77
            trial['type'] = 'sharedlosslocal'
            expData.append(trial)
            
for riskymagnitude in riskymagnitudes:
    for probability in probabilities:
        for hazard in sharedlosses:
            trial = {}
            trial['certainty'] = certainty
            trial['riskmagnitude'] = riskymagnitude
            trial['probability'] = probability
            trial['sharedloss'] = hazard
            trial['matchedEVW'] = -77
            trial['matchedEVL'] = -77
            trial['rt'] = -77 
            trial['choice'] = -77
            trial['outcome'] = -77
            trial['ttlrew'] = -77
            trial['type'] = 'sharedlossDuane'
            expData.append(trial)
            
for riskymagnitude in riskymagnitudes:
    for probability in probabilities:
        for hazard in sharedlosses:
            trial = {}
            trial['certainty'] = certainty
            trial['riskmagnitude'] = riskymagnitude
            trial['probability'] = probability
            trial['sharedloss'] = hazard
            trial['matchedEVW'] = -77
            trial['matchedEVL'] = -77
            trial['rt'] = -77 
            trial['choice'] = -77
            trial['outcome'] = -77
            trial['ttlrew'] = -77
            trial['type'] = 'sharedlossAsDuane'
            expData.append(trial)
        
for riskymagnitude in riskymagnitudes:
    for probability in probabilities:
        trial = {}
        trial['certainty'] = certainty
        trial['riskmagnitude'] = riskymagnitude
        trial['probability'] = probability
        trial['sharedloss'] = -77
        trial['matchedEVW'] = -77
        trial['matchedEVL'] = -77
        trial['rt'] = -77 
        trial['choice'] = -77
        trial['outcome'] = -77
        trial['ttlrew'] = -77
        trial['type'] = 'standard'
        expData.append(trial)
        
for probability in probabilities:
    trial = {}
    trial['certainty'] = certainty
    trial['riskmagnitude'] = catch_magnitude
    trial['probability'] = probability
    trial['sharedloss'] = -77
    trial['matchedEVW'] = -77
    trial['matchedEVL'] = -77
    trial['rt'] = -77
    trial['choice'] = -77
    trial['outcome'] = -77
    trial['ttlrew'] = -77
    trial['type'] = 'catch'
    expData.append(trial)

for EVW in matchedEVW:
    for probability in probabilities:
        trial = {}
        trial['certainty'] = certainty
        trial['riskmagnitude'] = -77
        trial['probability'] = probability
        trial['sharedloss'] = -77
        trial['matchedEVW'] = EVW
        trial['matchedEVL'] = EVW/2
        trial['rt'] = -77 
        trial['choice'] = -77
        trial['outcome'] = -77
        trial['ttlrew'] = -77
        trial['type'] = 'matched'
        expData.append(trial)
        
        
expData = misc.shuffleArray(expData)

#print(len(expData))
#for t in expData:
#    print(t)
#core.quit()


#--------------------------------------------------GET USER INFO
dlg = gui.Dlg(title="Decision-Making")
dlg.addText('')
dlg.addField('Subject Number:', 999)
dlg.addText('')
dlg.show()

if dlg.OK:
    SN = int(dlg.data[0])
    fileOut = 'moralhazard_' + str(SN)
    print fileOut

else:
    print 'user cancelled'
    core.quit()
    
#--------------------------------------------------OUTPUT FILE
logFile=open(fileOut+'.dlm', 'a')
logFile.write('\n\nExperiment began at: '+str(datetime.datetime.now()) + '\n\n')
logFile.flush()

#--------------------------------------------------INITIALISE STIMULI

# create a window to draw in
pyglet_screen = pyglet.window.get_platform().get_default_display().get_default_screen()
win = visual.Window((pyglet_screen.width, pyglet_screen.height),
    winType = 'pyglet', fullscr = False,
    units = 'norm', color = 'white')

ttlrew = 0

#--------------------------------------------------INSTRUCTIONS
# clear the screen
win.flip(clearBuffer=True)
# Wait for any key to begin
message = visual.TextStim(win,pos=(0.0,0.0), text='Experimenter, press any key to begin.', color=-1., colorSpace='rgb')
message.draw()
win.flip()

# Hide the mouse
mouse = event.Mouse()
mouse.setVisible(False)

waitKey()
time.sleep(.2)

message = visual.TextStim(win,pos=(0.0,0.0), color=-1., colorSpace='rgb',
    text = 'Waiting for remote player...')
message.draw()
win.flip()
time.sleep(8.5)


message = visual.TextStim(win,pos=(0.0,0.0), color=-1., colorSpace='rgb',
    wrapWidth = 1.5,
    text='\n\n'.join([
        'Player assignments:',
        player_assignments,
        "Remember: as Player C, you can choose to share losses with Player A or Player B, but you cannot lose money because of other players' choices.",
        'Press the spacebar to continue.']))
message.draw()
win.flip()
waitKey()
time.sleep(.1)

message = visual.TextStim(win,pos=(0.0,0.0), color=-1., colorSpace='rgb',
    wrapWidth = 1.5,
    text='''As Player C, there is also another type of shared-loss gamble that you will see, "Shared Loss (as Player B) with Player A". Losses from such gambles will be shared with Player A, but Player A will see the loss as coming from Player B, not from you.

Press the spacebar to continue.''')
message.draw()
win.flip()

waitKey()
win.flip()
time.sleep(2)
win.flip()

#--------------------------------------------------RUN GAMBLING TASK

timer = core.Clock()

for tn, trial in enumerate(expData):
    
    trial['time'] = datetime.datetime.now()
    
    trial['trial'] = tn + 1
    
    win.flip()
    
    drawtrial()
    
    win.flip()
    
    # wait for a choice
    timer.reset()

    outcome = 0
    choice = waitKey(keyList = ['up', 'down'])
    rt = timer.getTime()
                
    # log response
    trial['choice'] = int(choice == 'down')
    trial['rt'] = rt
    
    win.flip()
    
    outcome = drawoutcome(0)

    ttlrew = ttlrew + outcome
    trial['outcome'] = outcome
    trial['ttlrew'] = ttlrew
    
#    time.sleep(2)
#    win.flip()
#    time.sleep(2)
    
# clear the screen
    win.flip()

#    print(trial)
    log(logFile, trial)
    time.sleep(2)

# Unhide the mouse
mouse.setVisible(True)


#--------------------------------------------------ADMINISTER MANIPULATION CHECK

def err(text):
    wx.MessageBox(text, 'Error')

nickname_field_width = 200

default_wrap_width = 300
def wrapped_text(parent, message, wrap_width = default_wrap_width):
    x = wx.StaticText(parent, label = message)
    x.Wrap(wrap_width)
    return x

class NicknameInputDlg(wx.Dialog):
    def __init__(self, text):
        wx.Dialog.__init__(self, None,
            title = '',
            size = (670, 550),
            style = wx.DEFAULT_DIALOG_STYLE & ~wx.CLOSE_BOX)

        p = wx.Panel(self)

        self.person_types = shuffled(person_types.keys())
        self.labels = []
        self.fields = []
        for pt in self.person_types:
            self.labels.append(wx.StaticText(p, -1, person_types[pt]))
            self.fields.append(wx.TextCtrl(p, -1, size = (nickname_field_width, -1)))

        space = 5

        sizer = wx.FlexGridSizer(cols = 2, hgap=space, vgap=space)
        for x in concat(zip(self.labels, self.fields)):
            sizer.Add(x, flag = wx.ALIGN_CENTRE_VERTICAL)
        outer = wx.BoxSizer(wx.VERTICAL)
        outer.Add(wrapped_text(p, text, 650),
            flag = wx.ALIGN_CENTRE | wx.ALL,
            border = 10)
        outer.Add(sizer, 1, wx.ALL | wx.EXPAND, 25)
        outer.Add(wx.Button(p, wx.ID_OK), flag = wx.ALIGN_CENTRE)
        p.SetSizerAndFit(outer)

    def get_nicknames(self):
        return {k: x.GetValue().strip()
            for k, x in zip(self.person_types, self.fields)}

d = NicknameInputDlg(
    u"Below is a list of several types of people. Some of these types will include only one person for you, whereas others will include several. For each type, think of a particular person who fits the description. Then, in the blank, write a name we can use to refer to that person for this study. The name could be part of the person's actual name or it could be a short descriptionâ€”whatever is memorable enough that you won't forget what person the name refers to.")
#nicknames = {'remote_partner': u'duaney', 'unmet_classmate': u'class', 'best_friend': u'bff', 'parent': u'parent', 'doctor': u'doc', 'cashier': u'cashier', 'stranger': u'stranger', 'local_partner': u'thatguy', 'dead_relative': u'rel', 'childhood_friend': u'timmy', 'occ_relative': u'unclejoe', 'friend_of_friend': u'foaf'}
while True:
    if d.ShowModal() != wx.ID_OK:
        continue
    nicknames = d.get_nicknames()
    if any(s == "" for s in nicknames.values()):
        err('Please provide a name for every type of person.')
    elif len(set(nicknames.values())) != len(nicknames):
        err('No two names can be identical.')
    else:
        d.Destroy()
        break

class RankingDlg(wx.Dialog):
    def __init__(self, nicknames, text):
        wx.Dialog.__init__(self, None,
            title = '',
            size = (default_wrap_width + 25, 600),
            style = wx.DEFAULT_DIALOG_STYLE & ~wx.CLOSE_BOX)

        p = wx.Panel(self)

        self.nicknames = nicknames
        self.initial_nickname_order = shuffled(nicknames.values())

        self.lb = wx.ListBox(p,
            size = (default_wrap_width, 400),
            choices = self.initial_nickname_order)
        self.lb.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.lb)

        sz = wx.BoxSizer(wx.VERTICAL)
        sz.Add((0, 10))
        sz.Add(wrapped_text(p, text), flag = wx.ALIGN_CENTRE)
        sz.Add(self.lb, 1, flag = wx.EXPAND | wx.ALL, border = 10)
        sz.Add(wx.Button(p, wx.ID_OK), 0, flag = wx.ALIGN_CENTRE)
        p.SetSizerAndFit(sz)

    def OnKeyDown(self, event):
        keycode = event.GetKeyCode()
        if keycode == wx.WXK_UP:
            incr = -1
        elif keycode == wx.WXK_DOWN:
            incr = 1
        else:
            event.Skip()
            return
        # Move the selected item up or down the list.
        lb = event.GetEventObject()
        i = lb.GetSelection()
        if i + incr in (-1, lb.GetCount()):
          # The user is trying to go past the end of the list.
            return
        strs = lb.GetStrings()
        lb.Delete(i + incr)
        lb.Insert(strs[i + incr], i)

    def get_ranking(self):
        rnicknames = {v: k for k, v in self.nicknames.items()}
        return [rnicknames[k] for k in self.lb.GetStrings()]

d = RankingDlg(nicknames,
    "Now sort these people according to how close you feel to them. Put the person to whom you feel closest at the top and the person from whom you feel most distant at the bottom. Click on a name to select it, then use the arrow keys to move it up and down the list.")
while d.ShowModal() != wx.ID_OK: pass
distance_ranking = d.get_ranking()
d.Destroy()

print >>logFile
print >>logFile, json.dumps(dict(nicknames = nicknames, distance_ranking = distance_ranking))

#--------------------------------------------------LOG RESULTS

# clean up the log file
logFile.close()

# pickle the data
with open(fileOut+'.pkl', 'wb') as f:
    pickle.dump(dict(expData = expData, nicknames = nicknames, distance_ranking = distance_ranking),
        f)

#--------------------------------------------------FINISH UP
message = visual.TextStim(win,pos=(0,0), text='Your total earnings: $'+str(ttlrew)+'\n\nYou earned the $5 in real money!', color=[-1,-1,-1] ,colorSpace='rgb')
message.draw()
win.flip()
time.sleep(5)
win.flip()
message = visual.TextStim(win,pos=(0,0), text='Done with task!\n\nPlease wait for the experimenter.', color=[-1,-1,-1] ,colorSpace='rgb')
message.draw()
win.flip()
time.sleep(5)
waitKey()

mouse.setVisible(1)
win.close()
core.quit()
